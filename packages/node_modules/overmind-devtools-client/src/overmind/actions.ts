import {
  Action,
  pipe,
  Operator,
  AsyncAction,
  mutate,
  debounce,
  wait,
} from 'overmind'
import {
  Message,
  Tab,
  ExecutionType,
  ActionsListItemType,
  Component,
} from './types'
import * as o from './operators'
import { isValidJson, createApp, getActionId } from './utils'

export const onMessage: Operator<Message> = pipe(
  o.ensureCurrentApp(),
  o.ensureApp(),
  o.addClientMessage(),
  o.getMessage(),
  o.forkMessage({
    [ExecutionType.INIT]: o.addStateAndActions(),
    [ExecutionType.RE_INIT]: o.addStateAndActions(),
    [ExecutionType.FLUSH]: o.addFlush(),
    [ExecutionType.DERIVED]: o.updateDerived(),
    [ExecutionType.MUTATIONS]: o.addMutations(),
    [ExecutionType.EFFECT]: o.updateEffect(),
    [ExecutionType.STATE]: o.updateState(),
    [ExecutionType.COMPONENT_ADD]: o.addComponent(),
    [ExecutionType.COMPONENT_UPDATE]: o.updateComponent(),
    [ExecutionType.COMPONENT_REMOVE]: o.removeComponent(),
    [ExecutionType.DERIVED_DIRTY]: o.updateFlushWithDerived(),
    [ExecutionType.ACTION_START]: o.addAction(),
    [ExecutionType.OPERATOR_START]: o.addOperator(),
    [ExecutionType.OPERATOR_END]: o.updateOperator(),
    [ExecutionType.ACTION_END]: o.updateAction(),
    [ExecutionType.OPERATOR_ASYNC]: o.updateOperatorAsync(),
    [ExecutionType.GETTER]: o.runGetterMutation(),
    [ExecutionType.CHART]: o.addChart(),
  })
)

export const setError: Action<string> = ({ state }, error) => {
  state.error = error
}

export const onDisconnect: Action<string> = ({ state }, appName) => {
  if (appName in state.apps) {
    state.apps[appName] = createApp({
      name: appName,
    })
    state.apps[appName].connectionState = 'pending'
  }
}

export const changeNewPortValue: Action<string> = ({ state }, port) => {
  state.newPortValue = String(Number(port))
}

export const changeTab: Action<Tab> = ({ state, effects }, tab) => {
  state.currentTab = tab
  effects.storage.set(`${state.currentApp.name}.currentTab`, tab)
}

export const toggleExpandState: Action<string[]> = ({ state }, path) => {
  const pathString = path.join('.')

  if (state.currentApp.expandedStatePaths.indexOf(pathString) >= 0) {
    state.currentApp.expandedStatePaths.splice(
      state.currentApp.expandedStatePaths.indexOf(pathString),
      1
    )
  } else {
    state.currentApp.expandedStatePaths = state.currentApp.expandedStatePaths.concat(
      pathString
    )
  }
}

export const selectAction: Action<string> = ({ state }, actionId) => {
  for (let index in state.currentApp.actionsList) {
    const item = state.currentApp.actionsList[index]
    if (
      item.type === ActionsListItemType.GROUP &&
      item.id === actionId &&
      state.currentApp.currentActionId === actionId
    ) {
      item.isCollapsed = !item.isCollapsed
      break
    }
  }
  state.currentApp.currentActionId = actionId
}

export const toggleGroupedComponent: Action<string> = ({ state }, name) => {
  const index = state.currentApp.expandedComponents.indexOf(name)

  if (index === -1) {
    state.currentApp.expandedComponents.push(name)
  } else {
    state.currentApp.expandedComponents.splice(index, 1)
  }
}

export const selectApp: Action<string> = ({ state }, appName) => {
  state.currentAppName = appName
  state.showApps = false
}

export const toggleShowApps: Action = ({ state }) => {
  state.showApps = !state.showApps
}

export const toggleCollapsedComponent: Action<Component> = (_, component) => {
  component.isCollapsed = !component.isCollapsed
}

export const toggleQueryingAction: Action = ({ state }) => {
  state.currentApp.isQueryingAction = !state.currentApp.isQueryingAction
}

export const changeActionQuery: Action<string> = ({ state }, query) => {
  state.currentApp.actionQuery = query

  const hit = state.currentApp.actionPaths.find((path) =>
    path.startsWith(query)
  )

  if (query.length && hit) {
    state.currentApp.actionQuerySuggestion = hit
  } else {
    state.currentApp.actionQuerySuggestion = ''
  }
}

export const selectQueryAction: Action<string> = (
  { state, effects, actions },
  path
) => {
  const existingActionQuery = state.currentApp.selectedActionQuery

  state.currentApp.selectedActionQuery = path
  state.currentApp.isQueryingAction = false
  state.currentApp.actionQueryPayload = ''
  effects.storage.set(`${state.currentApp.name}.selectedActionQuery`, path)

  if (existingActionQuery === path) {
    actions.executeAction()
  }
}

export const submitQueryAction: Action = ({ state, effects }) => {
  if (!state.currentApp.actionQuerySuggestion) {
    return
  }

  state.currentApp.selectedActionQuery = state.currentApp.actionQuerySuggestion
  state.currentApp.isQueryingAction = false
  state.currentApp.actionQueryPayload = ''

  effects.storage.set(
    `${state.currentApp.name}.selectedActionQuery`,
    state.currentApp.selectedActionQuery
  )
}

export const executeAction: Operator = pipe(
  mutate(({ state, effects }) => {
    state.isExecutingAction = true

    const payload = state.currentApp.actionQueryPayload

    if (payload && !isValidJson(payload)) {
      return
    }

    effects.connector.sendMessage(state.currentApp.name, 'executeAction', {
      name: state.currentApp.selectedActionQuery,
      payload: state.currentApp.actionQueryPayload,
    })
  }),
  wait(500),
  mutate(({ state, effects }) => {
    state.currentApp.actionQueryPayload = ''
    effects.storage.set(`${state.currentApp.name}.actionQueryPayload`, '')
    state.isExecutingAction = false
  })
)

export const setActionQueryPayload: Action<string> = (
  { state, effects },
  payload
) => {
  state.currentApp.actionQueryPayload = payload
  effects.storage.set(`${state.currentApp.name}.actionQueryPayload`, payload)
}

export const setState: Action<string[]> = ({ state }, path) => {
  state.currentApp.selectedStatePath = path.join('.')
}

export const undoSettingState: Action = ({ state }) => {
  state.currentApp.selectedStatePath = null
}

export const submitState: Action<string> = ({ state, effects }, newState) => {
  const path = state.currentApp.selectedStatePath.split('.')

  effects.connector.sendMessage(state.currentApp.name, 'mutation', {
    path,
    value: newState,
  })

  state.currentApp.selectedStatePath = null
}

export const toggleRuntimeConfig: Action = ({ state }) => {
  state.isShowingRuntime = !state.isShowingRuntime
}

export const refreshApp: Action = ({ state, effects }) => {
  effects.connector.sendMessage(state.currentAppName, 'refresh')
}

export const setAppDataFromStorage: AsyncAction<{
  appName: string
  actions: string[]
}> = async ({ state, effects }, { appName, actions }) =>
  Promise.all([
    effects.storage.get<string>(`${appName}.selectedActionQuery`),
    effects.storage.get<string>(`${appName}.actionQueryPayload`),
    effects.storage.get<Tab>(`${appName}.currentTab`),
  ]).then(([selectedActionQuery, actionQueryPayload, tab]) => {
    const actionQuery =
      selectedActionQuery && actions.includes(selectedActionQuery)
        ? selectedActionQuery
        : ''
    state.apps[appName].selectedActionQuery = actionQuery
    state.apps[appName].actionQueryPayload = actionQuery
      ? actionQueryPayload
      : ''
    state.currentTab = tab || state.currentTab
  })

export const updateActionsSplitSize: Operator<number> = pipe(
  debounce(200),
  mutate(async ({ state, effects }, size) => {
    state.actionsSplitSize = size

    await effects.storage.set('devtool.actionsSplitSize', size)
  })
)

export const updateChartsSplitSize: Operator<number> = pipe(
  debounce(200),
  mutate(async ({ state, effects }, size) => {
    state.chartsSplitSize = size

    await effects.storage.set('devtool.chartsSplitSize', size)
  })
)

export const clearActions: Action = ({ state }) => {
  state.currentApp.actionsList = []
  state.currentApp.currentActionId = null
}

export const selectChart: Action<string> = ({ state }, id) => {
  state.currentApp.currentChartId = id
}
