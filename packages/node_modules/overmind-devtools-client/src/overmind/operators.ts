import { Operator, mutate, forEach, fork, createOperator, map } from 'overmind'
import {
  Message,
  AppMessage,
  InitMessage,
  FlushMessage,
  AddComponentMessage,
  UpdateComponentMessage,
  RemoveComponentMessage,
  DerivedMessage,
  DirtyDerivedMessage,
  ActionsListItemType,
  ActionItem,
  ActionGroupItem,
  StartActionMessage,
  StartOperatorMessage,
  EndOperatorMessage,
  EndActionMessage,
  MutationsMessage,
  EffectMessage,
  ExecutionType,
  AsyncOperatorMessage,
  EventType,
  Effect,
  GetterMessage,
  StateMessage,
  Tab,
  ChartMessage,
} from './types'
import {
  createApp,
  ensureFlushExists,
  getActionId,
  getOperatorId,
  runMutation,
} from './utils'

export const ensureCurrentApp: () => Operator<Message> = () =>
  mutate(({ state }, message) => {
    if (!state.currentAppName) {
      state.currentAppName = message.appName
    }
  })

export const runGetterMutation: () => Operator<GetterMessage> = () =>
  mutate(({ state }, message) => {
    runMutation(state.apps[message.appName].state)({
      method: 'set',
      path: message.data.path,
      args: [message.data.value],
    })
  })

export const addStateAndActions: () => Operator<InitMessage> = () =>
  mutate(({ state }, message) => {
    state.isConnecting = false
    state.error = null
    state.apps[message.appName].connectionState = 'connected'
    state.apps[message.appName].state = message.data.state
    state.apps[message.appName].actionPaths = message.data.actions
  })

export const addFlush: () => Operator<FlushMessage> = () =>
  mutate(({ state }, message) => {
    ensureFlushExists(state.apps[message.appName].flushes, message.data)
    state.apps[message.appName].flushes[message.data.flushId].mutations =
      message.data.mutations

    if (typeof message.data.operatorId === 'undefined') {
      state.apps[message.appName].flushByActionId[getActionId(message.data)] = {
        flushId: message.data.flushId,
      }
    } else {
      state.apps[message.appName].flushByOperatorId[
        getOperatorId(message.data)
      ] = {
        flushId: message.data.flushId,
      }
    }
  })

export const ensureApp: () => Operator<Message> = () =>
  mutate(({ state, effects, actions }, message) => {
    if (
      !state.apps[message.appName] ||
      message.message.type === ExecutionType.INIT
    ) {
      state.apps[message.appName] = createApp({
        name: message.appName,
      })

      // Do not use await, as it will block further execution, this stuff has to be sync
      actions.setAppDataFromStorage({
        appName: message.appName,
        actions: message.message.data.actions,
      })
    }
  })

export const addClientMessage: () => Operator<Message> = () =>
  mutate(({ state }, message) => {
    state.apps[message.appName].messages.unshift(
      JSON.parse(JSON.stringify(message.message))
    )
  })

export const addComponent: () => Operator<AddComponentMessage> = () =>
  mutate(({ state }, message) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id] = {
      id,
      isMounted: true,
      updateCount: 0,
      name: message.data.name,
      paths: message.data.paths,
      isCollapsed: true,
    }
  })

export const updateComponent: () => Operator<UpdateComponentMessage> = () =>
  mutate(({ state }, message) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id].paths = message.data.paths

    if ('flushId' in message.data) {
      state.apps[message.appName].components[id].updateCount++

      ensureFlushExists(state.apps[message.appName].flushes, message.data)

      if (
        state.apps[message.appName].flushes[
          message.data.flushId
        ].components.includes(id)
      ) {
        return
      }

      state.apps[message.appName].flushes[message.data.flushId].components.push(
        id
      )
    }
  })

export const removeComponent: () => Operator<RemoveComponentMessage> = () =>
  mutate(({ state }, message) => {
    const id = `${message.data.componentId}_${message.data.componentInstanceId}`

    state.apps[message.appName].components[id].isMounted = false
  })

export const updateDerived: () => Operator<DerivedMessage> = () =>
  mutate(({ state }, message) => {
    const appState = state.apps[message.appName].state
    const path = message.data.path.split('.')
    const key = path.pop()
    const target = path.reduce((aggr, pathKey) => aggr[pathKey], appState)
    target[key] = message.data.value

    state.apps[message.appName].derived[message.data.path] = message.data
  })

export const updateFlushWithDerived: () => Operator<DirtyDerivedMessage> = () =>
  mutate(({ state }, message) => {
    ensureFlushExists(state.apps[message.appName].flushes, message.data)
    state.apps[message.appName].flushes[message.data.flushId].derived.push(
      message.data.derivedPath
    )
  })

export const addAction: () => Operator<StartActionMessage> = () =>
  mutate(({ state }, message) => {
    const app = state.apps[message.appName]
    const action = message.data
    const actionId = getActionId(action)
    const isSelectingFirstAction =
      !app.currentActionId || app.currentActionId === app.actionsList[0].id

    app.actions[actionId] = {
      ...action,
      isRunning: true,
      operators: {},
      hasError: false,
      time: Date.now(),
    }

    if (action.parentExecution) {
      return
    }

    if (
      !app.actionsList.length ||
      app.actionsList[0].actionId !== action.actionId
    ) {
      app.actionsList.unshift({
        type: ActionsListItemType.ACTION,
        id: actionId,
        actionId: action.actionId,
      })
    } else if (app.actionsList[0].type === ActionsListItemType.ACTION) {
      const existingId = (app.actionsList[0] as ActionItem).id
      app.actionsList[0] = {
        type: ActionsListItemType.GROUP,
        id: actionId,
        actionId: action.actionId,
        isCollapsed: true,
        actionIds: [actionId, existingId],
      }
    } else if (app.actionsList[0].type === ActionsListItemType.GROUP) {
      ;(app.actionsList[0] as ActionGroupItem).actionIds.unshift(actionId)
      ;(app.actionsList[0] as ActionGroupItem).id = actionId
    }

    if (isSelectingFirstAction) {
      app.currentActionId = actionId
    }
  })

export const addChart: () => Operator<ChartMessage> = () =>
  mutate(({ state }, message) => {
    const app = state.apps[message.appName]
    const data = message.data
    const chartId = data.path.join('.')
    const isSelectingFirstChart = !app.currentChartId

    app.charts[chartId] = data

    if (isSelectingFirstChart) {
      app.currentChartId = chartId
    }
  })

export const addOperator: () => Operator<StartOperatorMessage> = () =>
  mutate(({ state }, message) => {
    const operatorData = message.data
    const actionId = getActionId(operatorData)
    const action = state.apps[message.appName].actions[actionId]
    const operator = {
      ...operatorData,
      isRunning: true,
      events: [],
    }

    if (operatorData.parentExecution && operatorData.operatorId === 0) {
      const parentActionId = getActionId(operatorData.parentExecution)
      const parentOperator =
        state.apps[message.appName].actions[parentActionId].operators[
          operatorData.parentExecution.operatorId
        ]

      parentOperator.events.push({
        type: EventType.Action,
        data: actionId,
      })
    }

    action.operators[operator.operatorId] = operator
  })

export const updateOperator: () => Operator<EndOperatorMessage> = () =>
  mutate(({ state }, message) => {
    const operatorData = message.data
    const actionId = getActionId(operatorData)
    const action = state.apps[message.appName].actions[actionId]
    const operator = action.operators[operatorData.operatorId]

    operator.isAsync = operatorData.isAsync
    operator.isRunning = false
    operator.result = operatorData.result
    operator.error = operatorData.error
    operator.isIntercepted = operatorData.isIntercepted
    operator.isSkipped = operatorData.isSkipped

    if (operator.error) {
      action.hasError = true
    }
  })

export const updateState: () => Operator<StateMessage> = () =>
  mutate(({ state }, message) => {
    const app = state.apps[message.appName]
    const path = message.data.path
    const key = path.pop()
    const target = path.reduce((aggr, key) => aggr[key], app.state)

    target[key] = message.data.value
  })

export const updateAction: () => Operator<EndActionMessage> = () =>
  mutate(({ state }, message) => {
    const app = state.apps[message.appName]
    const action = message.data
    const id = `${action.actionId}_${action.executionId}`

    app.actions[id].isRunning = false
  })

export const addMutations: () => Operator<MutationsMessage> = () =>
  mutate(({ state }, message) => {
    const mutations = message.data
    const id = `${mutations.actionId}_${mutations.executionId}`
    const operator =
      state.apps[message.appName].actions[id].operators[mutations.operatorId]

    operator.events = operator.events.concat(
      mutations.mutations.map((mutation) => ({
        type: EventType.Mutation,
        data: mutation,
      }))
    )

    message.data.mutations.forEach(
      runMutation(state.apps[message.appName].state)
    )
  })

export const updateEffect: () => Operator<EffectMessage> = () =>
  mutate(({ state }, message) => {
    const effect = message.data
    const id = getActionId(effect)
    const action = state.apps[message.appName].actions[id]
    const operator =
      state.apps[message.appName].actions[id].operators[effect.operatorId]
    const existingEvent = operator.events.find(
      (event) =>
        event.type === EventType.Effect &&
        (event.data as Effect).effectId === effect.effectId
    )

    if (existingEvent) {
      Object.assign(existingEvent.data, effect)
    } else {
      operator.events.push({
        type: EventType.Effect,
        data: effect,
      })
    }

    if (effect.error) {
      action.hasError = true
    }
  })

export const getMessage: () => Operator<Message, AppMessage<any>> = () =>
  map((_, value) => ({ ...value.message, appName: value.appName }))

export const forkMessage: (
  paths: {
    [key: string]: Operator<AppMessage<any>, any>
  }
) => Operator<AppMessage<any>> = (paths) =>
  fork((_, value) => value.type, paths) as Operator<AppMessage<any>>

export const updateOperatorAsync: () => Operator<AsyncOperatorMessage> = () =>
  mutate(() => {})
