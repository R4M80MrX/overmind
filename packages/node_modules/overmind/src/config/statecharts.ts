import {
  IConfig,
  IConfiguration,
  IDerive,
  filter,
  map,
  mutate,
  pipe,
} from '../'

const ACTIONS = 'ACTIONS'

export interface Statechart<C extends IConfiguration, S extends {
  [state: string]: Statecharts | void
}> {
  initial: keyof S
  states: {
    [N in keyof S]: {
      entry?: keyof C['actions']
      exit?: keyof C['actions']
      charts?: S[N],
      on?: {
        [N in keyof C['actions']]?:
          | keyof S
          | {
              target: keyof S
              condition: (state: C['state']) => boolean
            }
          | null
      }
    }
  }
}

interface Statecharts {
  [id: string]: Statechart<any, any>
}

function getActionTransitions(
  key: string,
  charts: Statecharts,
  state: { states: Array<(string | number)[]> }
) {
  const transitions: (string | boolean)[] = []
  state.states.forEach((statePath) => {
    const path = statePath.slice()

    while (path.length) {
      const target = getStateTarget(charts, path)

      if (target.entry === key) {
        transitions.push('entry')
        return
      }
      if (target.exit === key) {
        transitions.push('exit')
        return
      }
      if (target.on && target.on[key] === null) {
        transitions.push(true)
        return
      }
      if (target.on && typeof target.on[key] === 'string') {
        // If we have already transition to this path it means
        // we are moving away from multiple paths (parallel)
        if (transitions.includes(target.on[key])) {
          return
        }
        transitions.push(target.on[key])
        return
      }
      if (target.on && target.on[key] && target.on[key].condition(state)) {
        transitions.push(target.on[key].target)
        return
      }

      path.pop()
    }

    transitions.push(false)
  })

  return transitions
}

// We check if any transitions returned are not "false",
// which means any entry, exit or state transition should occur on
// any of existing state paths active
function getCanTransitionActions(actions, charts, state) {
  return Object.keys(actions || {}).reduce((aggr, key) => {
    aggr[key] = getActionTransitions(key, charts, state).some(
      (transition) => transition !== false
    )

    return aggr
  }, {})
}

function getMatchPaths(matches, paths: Array<string[]> = [[]]) {
  const initialPath = paths[paths.length - 1].slice()

  Object.keys(matches).forEach((matchKey, index) => {
    const match = matches[matchKey]
  
    if (index > 0) {
      paths.push(initialPath.slice())
    }

    paths[paths.length - 1].push(matchKey)

    if (typeof match !== 'boolean') {
      getMatchPaths(match, paths)
    }
  })

  return paths
}

function getInitialStates(charts: Statecharts, paths: Array<string[]> = [[]]) {
  const initialPath = paths[paths.length - 1].slice()

  Object.keys(charts).forEach((chartKey, index) => {
    const chart = charts[chartKey]
  
    if (index > 0) {
      paths.push(initialPath.slice())
    }

    paths[paths.length - 1].push(chartKey)
    paths[paths.length - 1].push(chart.initial as string)

    if (chart.states[chart.initial as string].charts) {
      getInitialStates(chart.states[chart.initial as string].charts as Statecharts, paths)
    }
  })

  return paths
}

function createNewStatePath(
  currentStates: Array<string[]>,
  transitionStates: string[],
  charts: Statecharts,
  index: number
) {
  const newStatePath: string[] = []
  let x = 0
  let transitionState = transitionStates.shift()

  // Keep existing state before transition
  while (!transitionState && transitionStates.length) {
    newStatePath.push(currentStates[index][x])
    transitionState = transitionStates.shift()
    x++
  }

  if (!transitionState) {
    return currentStates[index]
  }

  // Add the new transition
  newStatePath.push(transitionState)

  const stateTarget = getStateTarget(charts, newStatePath)

  // If we have more nested state, go grab the initial states
  if (stateTarget.chart) {
    return newStatePath.concat(getInitialStates(stateTarget.chart)[index])
  }

  return newStatePath
}

function getTarget(source, path) {
  return path.reduce((aggr, key) => aggr[key], source)
}

function getStateTarget(charts, path) {
  return path.reduce(
    (aggr, key, index) => {
      const isChart = index % 2
      
      if (!isChart) {
        return aggr[key]
      }

      if (index === path.length - 1) {
        return aggr.states[key]
      }

      return aggr.states[key].charts
    },
    charts
  )
}

type Match<T extends Statecharts> = {
  [I in keyof T]?: {
    [S in keyof T[I]["states"]]?: T[I]["states"][S]["charts"] extends void ? boolean : boolean | Match<T[I]["states"][S]["charts"]>
  }
}

export function statecharts<C extends IConfiguration, Charts extends Statecharts>(
  config: C,
  charts: Charts
): IConfig<{
  onInitialize: C['onInitialize']
  state: C['state'] & {
    states: Array<(string | number)[]>
    actions: { [N in keyof C['actions']]: boolean }
    matches: IDerive<any, any, (match: Match<Charts>) => boolean>
  }
  actions: C['actions']
  effects: C['effects']
}> & {
  onInitialize: C['onInitialize']
} {
  let currentInstance
  const actions = config.actions || {}
  const state = config.state || {}

  if (config.state && (config.state as any).states) {
    throw new Error(
      `Overmind statecharts: You have already defined the state "states" in your configuration. Statecharts needs this, please rename it`
    )
  }

  if (config.state && (config.state as any).matches) {
    throw new Error(
      `Overmind statecharts: You have already defined the state "matches" in your configuration. Statecharts needs this, please rename it`
    )
  }

  return {
    onInitialize: ((context, instance) => {
      if (config.onInitialize) {
        config.onInitialize(context, instance)
      }
      
      currentInstance = instance
      const stateTarget = getTarget(
        context.state,
        context.execution.namespacePath
      )
      const actions = getTarget(
        context.actions,
        context.execution.namespacePath
      )

      const statePaths = stateTarget.states.slice()

      statePaths.forEach((statePath) => {
        const state = statePath.slice()
        while (state.length) {
          const target = getStateTarget(charts, state)

          if (target.entry) {
            actions[target.entry]()
          }

          state.pop()
        }
      })

      if (process.env.NODE_ENV === 'development' && instance.devtools) {
        instance.devtools.send({
          type: 'chart',
          data: {
            path: context.execution.namespacePath,
            states: getInitialStates(charts),
            charts: charts,
            actions: getCanTransitionActions(actions, charts, stateTarget),
          },
        })
      }
    }) as any,
    state: Object.assign(state, {
      states: getInitialStates(charts),
      actions: ((state) =>
        getCanTransitionActions(actions, charts, state)) as any,
      matches: (state) => (match) => {
        const matchPaths = getMatchPaths(match)

        for (let x = 0; x < matchPaths.length; x++) {
          const matchPath = matchPaths[x]
          const shouldMatch = matchPath.reduce((aggr, key) => aggr[key], match)
          const hasMatch = state.states.reduce((aggr, statePath) => {
            if (aggr) {
              return aggr
            }

            return statePath.reduce((aggr, path, index) => {
              if (!aggr) {
                return aggr
              }

              return path === matchPath[index]
            }, true)
          }, false)

          if (shouldMatch !== hasMatch) {
            return false
          }
        }

        return true
      },
    }),
    actions: Object.keys(actions).reduce((aggr, key) => {
      aggr[key] = pipe(
        map(function getTransition({ state, execution }: any, payload) {
          const stateTarget = getTarget(state, execution.namespacePath)

          return {
            transitions: getActionTransitions(key, charts, stateTarget),
            payload,
          }
        }),
        filter(function canTransition(_, { transitions }) {
          return transitions.some((transition) => transition !== false)
        }),
        mutate(function runAction(context: any, { transitions, payload }) {
          const stateTarget = getTarget(
            context.state,
            context.execution.namespacePath
          )
          const actionsTarget = getTarget(
            context.actions,
            context.execution.namespacePath
          )

          const resolvedActions = getTarget(
            context.actions,
            context.execution.namespacePath
          )
          const newStates: Array<(string | number)[]> = []

          if (transitions.includes('entry') || transitions.includes('exit')) {
            actionsTarget[ACTIONS][key](payload)
          }

          transitions.forEach((transition, index) => {
            const oldStatePath = stateTarget.states[index].slice()

            if (transition === 'entry' || transition === 'exit') {
              newStates.push(oldStatePath)
              return  
            }
            
            const currentStatePath = stateTarget.states[index].slice()
            const stateTransitions = currentStatePath.map(() => null)

            // Build new transition path
            while (currentStatePath.length) {
              const target = getStateTarget(charts, currentStatePath)

              // Collect the new transition state
              if (target.on && target.on[key]) {
                stateTransitions[currentStatePath.length - 1] =
                  target.on[key].target || target.on[key]
              }

              currentStatePath.pop()
            }

            const newStatePath = createNewStatePath(
              stateTarget.states,
              stateTransitions,
              charts,
              index
            )

            // Go down old path and trigger exits where the state has changed
            const traverseOldPath = oldStatePath.slice()
            while (traverseOldPath.length) {
              const target = getStateTarget(charts, traverseOldPath)

              if (
                target.exit &&
                newStatePath[traverseOldPath.length - 1] !==
                  oldStatePath[traverseOldPath.length - 1]
              ) {
                resolvedActions[target.exit]()
              }

              traverseOldPath.pop()
            }

            newStates.push(newStatePath.slice())

            // Go down new path and trigger any entry on new states
            const traverseNewPath = newStatePath.slice()
            while (traverseNewPath.length) {
              const target = getStateTarget(charts, traverseNewPath)

              if (
                target.entry &&
                newStatePath[traverseNewPath.length - 1] !==
                  oldStatePath[traverseNewPath.length - 1]
              ) {
                resolvedActions[target.entry]()
              }

              traverseNewPath.pop()
            }

  
            if (transition) {
              actionsTarget[ACTIONS][key](payload)
            }
          })

          // Actually change what has changed
          stateTarget.states = newStates

          if (process.env.NODE_ENV === 'development' && currentInstance.devtools) {
            currentInstance.devtools.send({
              type: 'chart',
              data: {
                path: context.execution.namespacePath,
                states: stateTarget.states,
                charts: charts,
                actions: getCanTransitionActions(
                  config.actions,
                  charts,
                  stateTarget
                ),
              },
            })
          }
        })
      )

      return aggr
    }, {
      [ACTIONS]: actions
    }),
    effects: config.effects || {},
  }
}