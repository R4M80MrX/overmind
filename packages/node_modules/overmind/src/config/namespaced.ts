import { IConfiguration } from '../'
import { SubType } from '../internalTypes'

interface NamespacedConfiguration {
  [namespace: string]: {
    onInitialize?: any
    state?: {}
    effects?: {}
    actions?: {}
    reactions?: {}
  }
}

function parseNamespacedConfig(
  result: { actions: any; effects: any; state: any; initializers: any },
  name: string,
  config: IConfiguration
) {
  const { actions, effects, onInitialize, state }: IConfiguration = config

  if (actions) {
    result.actions[name] = actions
  }
  if (effects) {
    result.effects[name] = effects
  }
  if (state) {
    result.state[name] = state
  }
  if (onInitialize) {
    result.initializers[name] = onInitialize
  }
}

export function namespaced<T extends NamespacedConfiguration>(
  namespaces: T
): {
  onInitialize?: any
  state: SubType<{ [P in keyof T]: T[P]['state'] }, object>
  effects: SubType<{ [P in keyof T]: T[P]['effects'] }, object>
  actions: SubType<{ [P in keyof T]: T[P]['actions'] }, object>
} {
  const result: any = {
    initializers: {},
    actions: {},
    effects: {},
    state: {},
  }

  Object.keys(namespaces).forEach((name) => {
    parseNamespacedConfig(result, name, namespaces[name])
  })

  return Object.assign({
    actions: result.actions,
    effects: result.effects,
    state: result.state,
    onInitialize: (context, app) =>
      Promise.all(
        Object.keys(result.initializers).map((key) =>
          result.initializers[key](
            {
              ...context,
              execution: {
                ...context.execution,
                namespacePath: context.execution.namespacePath.concat(key),
              },
            },
            app
          )
        )
      ),
  })
}
