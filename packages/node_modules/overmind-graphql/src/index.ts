import { GraphQLClient } from 'graphql-request'
import { Headers as HttpHeaders, Options } from 'graphql-request/dist/src/types'
import { print } from 'graphql/language/printer'
import { IConfiguration } from 'overmind'
import { ResolveState } from 'overmind/lib/internalTypes'

export { default as gql } from 'graphql-tag'

export interface Query<Result extends any, Payload extends any = void> {
  (payload: Payload): Result
}

export function graphql<
  C extends IConfiguration,
  G extends {
    endpoint: string
    headers?: (state: ResolveState<C['state']>) => HttpHeaders
    options?: Options
    queries?: {
      [key: string]: (payload: any) => any
    }
    mutations?: {
      [key: string]: (payload: any) => any
    }
  }
>(
  initialConfig: C,
  options: G
): {
  state: C['state']
  effects: C['effects'] & {
    queries: {
      [N in keyof G['queries']]: G['queries'][N] extends (
        payload: infer P
      ) => infer R
        ? P extends void
          ? () => R
          : (payload: P) => R
        : never
    }
    mutations: {
      [N in keyof G['mutations']]: G['mutations'][N] extends (
        payload: infer P
      ) => infer R
        ? P extends void
          ? () => R
          : (payload: P) => R
        : never
    }
  }
  actions: C['actions']
} {
  const config: any = {}
  let _client: GraphQLClient
  let _state

  if (config.effects && config.effects.queries) {
    throw new Error(
      `Overmind Graphql - There is already a "queries" effect on this configuration, please rename that to something else`
    )
  }

  if (config.effects && config.effects.mutations) {
    throw new Error(
      `Overmind Graphql - There is already a "mutations" effect on this configuration, please rename that to something else`
    )
  }

  config.onInitialize = (context, payload) => {
    _state = context.state
    _client = new GraphQLClient(options.endpoint, {
      ...options.options,
      headers:
        typeof options.headers === 'function'
          ? options.headers(context.state)
          : options.options
          ? options.options.headers
          : {},
    })
    return (
      initialConfig.onInitialize && initialConfig.onInitialize(context, payload)
    )
  }
  config.state = initialConfig.state
  config.effects = Object.assign(initialConfig.effects || {}, {
    queries: Object.keys(options.queries || {}).reduce((aggr, key) => {
      aggr[key] = (variables) => {
        if (!_client) {
          throw new Error(
            `You have not connected to your GraphQL endpoint, please run "connect" first`
          )
        }
        const query = options.queries[key] as any

        if (typeof options.headers === 'function') {
          _client.setHeaders(options.headers(_state))
        }

        return _client.request(print(query), variables)
      }
      return aggr
    }, {}),
    mutations: Object.keys(options.mutations || {}).reduce((aggr, key) => {
      aggr[key] = (variables) => {
        if (!_client) {
          throw new Error(
            `You have not connected to your GraphQL endpoint, please run "connect" first`
          )
        }
        const query = options.mutations[key] as any

        if (typeof options.headers === 'function') {
          _client.setHeaders(options.headers(_state))
        }

        return _client.request(print(query), variables)
      }
      return aggr
    }, {}),
  })
  config.actions = initialConfig.actions

  return config as any
}
